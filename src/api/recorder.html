<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Stroke Recorder</title>
    <style>
      :root {
        color-scheme: light;
      }

      body {
        margin: 0;
        padding: 24px;
        font-family: Arial, Helvetica, sans-serif;
        background: #f4f4f4;
        color: #111;
      }

      .container {
        max-width: 720px;
        margin: 0 auto;
      }

      .status-bar {
        display: flex;
        align-items: center;
        justify-content: flex-end;
        gap: 12px;
        background: #ffffff;
        border: 1px solid #d0d0d0;
        border-radius: 8px 8px 0 0;
        padding: 10px 14px;
        box-sizing: border-box;
      }

      .stats {
        font-family: "Courier New", Courier, monospace;
        font-size: 13px;
        text-align: right;
        color: #333;
        min-width: 180px;
      }

      .stats span {
        display: block;
      }

      .top-preview img {
        width: 56px;
        height: 56px;
        border: 1px solid #c0c0c0;
        border-radius: 4px;
        background: #fff;
        display: block;
      }

      .canvas-wrap {
        border: 1px solid #d0d0d0;
        border-top: none;
        border-radius: 0 0 8px 8px;
        background: #ffffff;
        padding: 12px;
        box-sizing: border-box;
      }

      canvas {
        width: 100%;
        height: auto;
        display: block;
        background: #ffffff;
        border: 1px solid #c0c0c0;
        border-radius: 6px;
      }

      .hint {
        margin-top: 12px;
        font-size: 13px;
        color: #666;
      }

    </style>
  </head>
  <body>
    <div class="container">
      <div class="status-bar">
        <div class="top-preview">
          <img id="previewImg" alt="preview" />
        </div>
        <div class="stats">
          <span>confidence: <span id="confidence">--</span></span>
          <span>inference: <span id="inferenceMs">--</span></span>
        </div>
      </div>
      <div class="canvas-wrap">
        <canvas id="pad" width="640" height="420"></canvas>
        <div class="hint">Move the mouse over the canvas to record a stroke.</div>
      </div>
    </div>

    <script>
      const API_BASE = "";
      const canvas = document.getElementById("pad");
      const ctx = canvas.getContext("2d");
      const confidenceEl = document.getElementById("confidence");
      const inferenceEl = document.getElementById("inferenceMs");
      const previewImg = document.getElementById("previewImg");

      const sampleIntervalMs = 10;
      const inactivityMs = 250;
      const minSamples = 3;

      let recordingActive = false;
      let samplingTimer = null;
      let currentPos = null;
      let lastLoggedPos = null;
      let lastMoveTime = 0;
      let rows = [];
      let lastDrawPos = null;
      let flashAnimationId = null;
      let flashStartTime = 0;

      function clearCanvas() {
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      function drawLine(from, to) {
        ctx.strokeStyle = "#111111";
        ctx.lineWidth = 2;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();
      }

      function startSampling() {
        if (samplingTimer) {
          clearInterval(samplingTimer);
        }
        samplingTimer = setInterval(sampleVelocity, sampleIntervalMs);
      }

      function startRecording(pos) {
        recordingActive = true;
        rows = [];
        currentPos = { x: pos.x, y: pos.y };
        lastLoggedPos = { x: pos.x, y: pos.y };
        lastMoveTime = performance.now();
        startSampling();
      }

      function sampleVelocity() {
        if (!recordingActive) {
          return;
        }
        const timestamp = new Date().toISOString();
        const vx = currentPos.x - lastLoggedPos.x;
        const vy = currentPos.y - lastLoggedPos.y;
        lastLoggedPos = { x: currentPos.x, y: currentPos.y };
        rows.push([timestamp, vx, vy]);

        if (performance.now() - lastMoveTime >= inactivityMs && rows.length >= minSamples) {
          stopRecording();
        }
      }

      function cancelFlash() {
        if (flashAnimationId) {
          cancelAnimationFrame(flashAnimationId);
          flashAnimationId = null;
        }
      }

      function flashLetter(letter) {
        if (!letter) {
          return;
        }
        cancelFlash();
        flashStartTime = performance.now();
        const durationMs = 500;
        const fontSize = Math.min(canvas.width, canvas.height) * 0.65;

        function animate(now) {
          const elapsed = now - flashStartTime;
          const t = Math.min(1, elapsed / durationMs);
          clearCanvas();
          ctx.save();
          ctx.globalAlpha = 1 - t;
          ctx.fillStyle = "#111111";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.font = `bold ${fontSize}px Arial, Helvetica, sans-serif`;
          ctx.fillText(letter, canvas.width / 2, canvas.height / 2);
          ctx.restore();

          if (t < 1) {
            flashAnimationId = requestAnimationFrame(animate);
          } else {
            flashAnimationId = null;
            clearCanvas();
          }
        }

        flashAnimationId = requestAnimationFrame(animate);
      }

      async function stopRecording() {
        recordingActive = false;
        if (samplingTimer) {
          clearInterval(samplingTimer);
          samplingTimer = null;
        }
        if (rows.length === 0) {
          return;
        }
        cancelFlash();
        clearCanvas();

        const csvLines = ["timestamp,velocity_x,velocity_y"];
        for (const row of rows) {
          csvLines.push(`${row[0]},${row[1]},${row[2]}`);
        }
        const csvContent = csvLines.join("\n");
        const blob = new Blob([csvContent], { type: "text/csv" });
        const formData = new FormData();
        formData.append("file", blob, "stroke.csv");

        try {
          await fetch(`${API_BASE}/record`, {
            method: "POST",
            body: formData,
          });

          const predictStart = performance.now();
          const predictResponse = await fetch(`${API_BASE}/predict`, {
            method: "POST",
            body: formData,
          });
          const predictData = await predictResponse.json();
          const predictElapsed = performance.now() - predictStart;

          clearCanvas();
          flashLetter(predictData.predicted_char);
          if (typeof predictData.confidence === "number") {
            confidenceEl.textContent = `${predictData.confidence.toFixed(1)}%`;
          }
          if (typeof predictData.inference_ms === "number") {
            inferenceEl.textContent = `${predictData.inference_ms.toFixed(1)} ms`;
          } else {
            inferenceEl.textContent = `${predictElapsed.toFixed(1)} ms`;
          }
          if (predictData.image_data_url) {
            previewImg.src = predictData.image_data_url;
          }
        } catch (error) {
          console.error("Failed to send stroke data", error);
        }

        rows = [];
        lastDrawPos = null;
      }

      function getCanvasPos(event) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return {
          x: (event.clientX - rect.left) * scaleX,
          y: (event.clientY - rect.top) * scaleY,
        };
      }

      canvas.addEventListener("mousemove", (event) => {
        const pos = getCanvasPos(event);
        if (!recordingActive) {
          cancelFlash();
          startRecording(pos);
        }
        currentPos = { x: pos.x, y: pos.y };
        lastMoveTime = performance.now();

        if (lastDrawPos) {
          drawLine(lastDrawPos, pos);
        }
        lastDrawPos = { x: pos.x, y: pos.y };
      });

      canvas.addEventListener("mouseleave", () => {
        lastDrawPos = null;
      });

      clearCanvas();
    </script>
  </body>
</html>
