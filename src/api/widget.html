<!--
  scribble Embeddable Widget - Apple Watch Scribble Style

  Features a grid of dots that light up as you draw, then coalesce
  toward the center when a character is recognized.
-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>scribble - Draw to Decode</title>
    <style>
      :root {
        color-scheme: light;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        padding: 24px;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        background: #f4f4f4;
        color: #111;
      }

      .scribble-container {
        max-width: 720px;
        margin: 0 auto;
      }

      .scribble-header {
        margin-bottom: 16px;
      }

      .scribble-header h2 {
        margin: 0 0 4px 0;
        font-size: 20px;
        font-weight: 600;
      }

      .scribble-header p {
        margin: 0;
        font-size: 14px;
        color: #666;
      }

      .scribble-status-bar {
        display: flex;
        align-items: center;
        justify-content: space-between;
        background: #ffffff;
        border: 1px solid #d0d0d0;
        border-radius: 8px 8px 0 0;
        padding: 10px 14px;
      }

      .scribble-output {
        font-family: "SF Mono", "Monaco", "Inconsolata", "Fira Mono", "Droid Sans Mono", monospace;
        font-size: 16px;
        background: #f8f8f8;
        border: 1px solid #e0e0e0;
        border-radius: 4px;
        padding: 8px 12px;
        min-width: 240px;
        max-width: 400px;
        min-height: 28px;
        word-wrap: break-word;
        color: #333;
        letter-spacing: 0.5px;
      }

      .scribble-output:empty::before {
        content: "Start drawing...";
        color: #999;
      }

      .scribble-output .new-char {
        animation: charPop 0.3s ease-out;
      }

      @keyframes charPop {
        0% {
          color: #14428B;
          transform: scale(1.3);
        }
        100% {
          color: #333;
          transform: scale(1);
        }
      }

      .scribble-stats-row {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .scribble-preview img {
        width: 48px;
        height: 48px;
        border: 1px solid #c0c0c0;
        border-radius: 4px;
        background: #fff;
        display: block;
      }

      .scribble-stats {
        font-family: "SF Mono", "Monaco", "Inconsolata", "Fira Mono", "Droid Sans Mono", monospace;
        font-size: 12px;
        text-align: right;
        color: #666;
        min-width: 120px;
      }

      .scribble-stats span {
        display: block;
      }

      .scribble-canvas-wrap {
        border: 1px solid #d0d0d0;
        border-top: none;
        border-radius: 0 0 8px 8px;
        background: #ffffff;
        padding: 12px;
      }

      .scribble-canvas {
        width: 100%;
        height: auto;
        display: block;
        background: #fafafa;
        border: 1px solid #e0e0e0;
        border-radius: 6px;
        cursor: crosshair;
        touch-action: none;
      }

      .scribble-hint {
        margin-top: 10px;
        font-size: 12px;
        color: #888;
      }

      .scribble-error {
        color: #d32f2f;
        font-size: 12px;
        margin-top: 8px;
        display: none;
      }

      .scribble-error.visible {
        display: block;
      }
    </style>
  </head>
  <body>
    <div class="scribble-container">
      <div class="scribble-header">
        <h2>scribble</h2>
        <p>Draw characters with your mouse. The model decodes your strokes in real-time.</p>
      </div>

      <div class="scribble-status-bar">
        <div class="scribble-output" id="scribbleOutput"></div>
        <div class="scribble-stats-row">
          <div class="scribble-preview">
            <img id="scribblePreview" alt="preview" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNk+A8AAQUBAScY42YAAAAASUVORK5CYII=" />
          </div>
          <div class="scribble-stats">
            <span>conf: <span id="scribbleConfidence">--</span></span>
            <span>time: <span id="scribbleInference">--</span></span>
          </div>
        </div>
      </div>

      <div class="scribble-canvas-wrap">
        <canvas id="scribbleCanvas" class="scribble-canvas" width="640" height="360"></canvas>
        <div class="scribble-hint">Move mouse over canvas to draw. Pause briefly between characters.</div>
        <div class="scribble-error" id="scribbleError"></div>
      </div>
    </div>

    <script>
      (function () {
        // ============================================================
        // CONFIGURATION
        // ============================================================
        const isLocal = window.location.hostname === "localhost" ||
                        window.location.hostname === "127.0.0.1";
        const API_BASE = isLocal ? "" : "https://api.hectorastrom.com";

        // Grid settings
        const GRID_SPACING = 6;
        const DOT_RADIUS = 1;
        const DOT_COLOR_IDLE = "rgba(180, 180, 180, 0.4)";
        const DOT_COLOR_LIT = "#14428B";
        const ACTIVATION_RADIUS = 4;

        // Animation settings
        const COALESCE_DURATION_MS = 250;
        const POUR_OUT_DURATION_MS = 100;
        const COALESCE_EASING = (t) => 1 - Math.pow(1 - t, 3); // ease-out cubic

        // ============================================================

        const canvas = document.getElementById("scribbleCanvas");
        const ctx = canvas.getContext("2d");
        const outputEl = document.getElementById("scribbleOutput");
        const confidenceEl = document.getElementById("scribbleConfidence");
        const inferenceEl = document.getElementById("scribbleInference");
        const previewImg = document.getElementById("scribblePreview");
        const errorEl = document.getElementById("scribbleError");

        // Sampling configuration
        const sampleIntervalMs = 10;
        const inactivityMs = 300;
        const minSamples = 3;

        // State
        let recordingActive = false;
        let samplingTimer = null;
        let currentPos = null;
        let lastLoggedPos = null;
        let lastCursorPos = null; // For interpolating dot highlights
        let lastMoveTime = 0;
        let recordingStartTime = 0;
        let velocities = [];
        let decodedOutput = "";
        const MAX_OUTPUT_CHARS = 21;
        const MAX_STROKE_DURATION_MS = 2500; // don't send any stroke longer than this

        // Grid state
        let dots = [];
        let litDots = new Set();
        let animatingDots = [];
        let animationId = null;
        let isAnimating = false;

        // Initialize dot grid
        function initGrid() {
          dots = [];
          const cols = Math.floor((canvas.width - GRID_SPACING) / GRID_SPACING);
          const rows = Math.floor((canvas.height - GRID_SPACING) / GRID_SPACING);
          const offsetX = (canvas.width - cols * GRID_SPACING) / 2;
          const offsetY = (canvas.height - rows * GRID_SPACING) / 2;

          for (let row = 0; row <= rows; row++) {
            for (let col = 0; col <= cols; col++) {
              dots.push({
                x: offsetX + col * GRID_SPACING,
                y: offsetY + row * GRID_SPACING,
                col,
                row,
                lit: false,
              });
            }
          }
        }

        function drawDot(x, y, color, radius = DOT_RADIUS) {
          ctx.beginPath();
          ctx.arc(x, y, radius, 0, Math.PI * 2);
          ctx.fillStyle = color;
          ctx.fill();
        }

        function renderGrid() {
          ctx.fillStyle = "#fafafa";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          for (const dot of dots) {
            if (!litDots.has(dot)) {
              drawDot(dot.x, dot.y, DOT_COLOR_IDLE);
            }
          }

          // Draw lit dots on top
          for (const dot of litDots) {
            drawDot(dot.x, dot.y, DOT_COLOR_LIT, DOT_RADIUS + 1);
          }
        }

        function renderAnimatingDots() {
          ctx.fillStyle = "#fafafa";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          // Draw idle grid
          for (const dot of dots) {
            drawDot(dot.x, dot.y, DOT_COLOR_IDLE);
          }

          // Draw animating dots
          for (const ad of animatingDots) {
            const alpha = 1 - ad.progress * 0.3;
            ctx.globalAlpha = alpha;
            drawDot(ad.currentX, ad.currentY, DOT_COLOR_LIT, DOT_RADIUS + 1);
          }
          ctx.globalAlpha = 1;
        }

        function lightUpNearbyDots(x, y) {
          for (const dot of dots) {
            if (litDots.has(dot)) continue;
            const dx = dot.x - x;
            const dy = dot.y - y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist <= ACTIVATION_RADIUS) {
              dot.lit = true;
              litDots.add(dot);
            }
          }
        }

        // Light up dots along a line from (x1,y1) to (x2,y2)
        function lightUpDotsAlongPath(x1, y1, x2, y2) {
          const dx = x2 - x1;
          const dy = y2 - y1;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist === 0) {
            lightUpNearbyDots(x1, y1);
            return;
          }

          // Sample points along the path at intervals smaller than ACTIVATION_RADIUS
          const stepSize = ACTIVATION_RADIUS * 0.5;
          const steps = Math.ceil(dist / stepSize);

          for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            const x = x1 + dx * t;
            const y = y1 + dy * t;
            lightUpNearbyDots(x, y);
          }
        }

        function clearLitDots() {
          for (const dot of dots) {
            dot.lit = false;
          }
          litDots.clear();
          animatingDots = [];
          if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
          }
          isAnimating = false;
        }

        // Calculate grid-constrained path from start to target
        function calculateGridPath(startX, startY, startCol, startRow, targetX, targetY) {
          // Find the target column (center top of canvas)
          const cols = Math.floor((canvas.width - GRID_SPACING) / GRID_SPACING);
          const targetCol = Math.floor(cols / 2);
          const targetRow = 2; // Near top

          const offsetX = (canvas.width - cols * GRID_SPACING) / 2;
          const offsetY = (canvas.height - Math.floor((canvas.height - GRID_SPACING) / GRID_SPACING) * GRID_SPACING) / 2;

          // Create waypoints: first move horizontally, then vertically
          const waypoints = [];

          // Current position
          waypoints.push({ x: startX, y: startY });

          // Move horizontally to target column
          const midX = offsetX + targetCol * GRID_SPACING;
          if (Math.abs(startCol - targetCol) > 0) {
            waypoints.push({ x: midX, y: startY });
          }

          // Move vertically to target row
          const finalY = offsetY + targetRow * GRID_SPACING;
          waypoints.push({ x: midX, y: finalY });

          return waypoints;
        }

        function startCoalesceAnimation() {
          if (litDots.size === 0) return;

          isAnimating = true;
          animatingDots = [];

          // Target: horizontal center line near top
          const targetX = canvas.width / 2;
          const targetY = GRID_SPACING * 4;

          for (const dot of litDots) {
            const waypoints = calculateGridPath(
              dot.x, dot.y, dot.col, dot.row,
              targetX, targetY
            );

            // Calculate total distance for this path
            let totalDist = 0;
            for (let i = 1; i < waypoints.length; i++) {
              const dx = waypoints[i].x - waypoints[i - 1].x;
              const dy = waypoints[i].y - waypoints[i - 1].y;
              totalDist += Math.sqrt(dx * dx + dy * dy);
            }

            // Add slight delay based on distance from center (creates wave effect)
            const distFromTarget = Math.sqrt(
              Math.pow(dot.x - targetX, 2) + Math.pow(dot.y - targetY, 2)
            );
            const maxDist = Math.sqrt(canvas.width * canvas.width + canvas.height * canvas.height) / 2;
            const delayFactor = (distFromTarget / maxDist) * 0.3;

            animatingDots.push({
              startX: dot.x,
              startY: dot.y,
              currentX: dot.x,
              currentY: dot.y,
              waypoints,
              totalDist,
              progress: 0,
              delay: delayFactor,
              coalesceY: waypoints[waypoints.length - 1].y, // Store the final Y from coalesce phase
            });
          }

          const startTime = performance.now();
          let phase = 1; // 1 = coalesce, 2 = pour out
          let phase2StartTime = null;

          function animate(now) {
            const elapsed = now - startTime;

            if (phase === 1) {
              // Phase 1: Coalesce to center line
              const baseProgress = Math.min(1, elapsed / COALESCE_DURATION_MS);
              let allDone = true;

              for (const ad of animatingDots) {
                // Apply individual delay
                const adjustedProgress = Math.max(0, (baseProgress - ad.delay) / (1 - ad.delay));
                ad.progress = COALESCE_EASING(Math.min(1, adjustedProgress));

                if (ad.progress < 1) {
                  allDone = false;
                }

                // Calculate position along path
                const targetDist = ad.progress * ad.totalDist;
                let traveled = 0;

                for (let i = 1; i < ad.waypoints.length; i++) {
                  const dx = ad.waypoints[i].x - ad.waypoints[i - 1].x;
                  const dy = ad.waypoints[i].y - ad.waypoints[i - 1].y;
                  const segmentDist = Math.sqrt(dx * dx + dy * dy);

                  if (traveled + segmentDist >= targetDist) {
                    const segmentProgress = segmentDist > 0 ? (targetDist - traveled) / segmentDist : 0;
                    ad.currentX = ad.waypoints[i - 1].x + dx * segmentProgress;
                    ad.currentY = ad.waypoints[i - 1].y + dy * segmentProgress;
                    break;
                  }
                  traveled += segmentDist;
                }

                // Snap to final position if done
                if (ad.progress >= 1) {
                  const last = ad.waypoints[ad.waypoints.length - 1];
                  ad.currentX = last.x;
                  ad.currentY = last.y;
                }
              }

              renderAnimatingDots();

              if (allDone) {
                // Transition to phase 2
                phase = 2;
                phase2StartTime = now;
                // Store current positions as starting points for phase 2
                for (const ad of animatingDots) {
                  ad.phase2StartX = ad.currentX;
                  ad.phase2StartY = ad.currentY;
                  ad.progress = 0;
                }
              }

              animationId = requestAnimationFrame(animate);
            } else if (phase === 2) {
              // Phase 2: Pour out - move dots up and out of canvas
              const phase2Elapsed = now - phase2StartTime;
              const baseProgress = Math.min(1, phase2Elapsed / POUR_OUT_DURATION_MS);
              const easedProgress = COALESCE_EASING(baseProgress);

              // Target Y is above the canvas (negative)
              const exitY = -DOT_RADIUS * 4;

              for (const ad of animatingDots) {
                ad.progress = easedProgress;
                ad.currentX = ad.phase2StartX; // Keep X constant
                ad.currentY = ad.phase2StartY + (exitY - ad.phase2StartY) * easedProgress;
              }

              renderAnimatingDots();

              if (baseProgress < 1) {
                animationId = requestAnimationFrame(animate);
              } else {
                // Animation complete - reset
                clearLitDots();
                renderGrid();
              }
            }
          }

          animationId = requestAnimationFrame(animate);
        }

        function showError(msg) {
          errorEl.textContent = msg;
          errorEl.classList.add("visible");
          setTimeout(() => errorEl.classList.remove("visible"), 5000);
        }

        function startSampling() {
          if (samplingTimer) {
            clearInterval(samplingTimer);
          }
          samplingTimer = setInterval(sampleVelocity, sampleIntervalMs);
        }

        function startRecording(pos) {
          recordingActive = true;
          velocities = [];
          currentPos = { x: pos.x, y: pos.y };
          lastLoggedPos = { x: pos.x, y: pos.y };
          lastCursorPos = { x: pos.x, y: pos.y };
          lastMoveTime = performance.now();
          recordingStartTime = performance.now();
          startSampling();
        }

        function sampleVelocity() {
          if (!recordingActive) return;

          const vx = currentPos.x - lastLoggedPos.x;
          const vy = currentPos.y - lastLoggedPos.y;
          lastLoggedPos = { x: currentPos.x, y: currentPos.y };
          velocities.push({ vx, vy });

          if (performance.now() - lastMoveTime >= inactivityMs && velocities.length >= minSamples) {
            stopRecording();
          }
        }

        async function stopRecording() {
          recordingActive = false;
          if (samplingTimer) {
            clearInterval(samplingTimer);
            samplingTimer = null;
          }

          const vels = velocities;
          if (vels.length === 0) return;

          // Check if stroke took too long (> 3 seconds) - discard if so
          const strokeDuration = performance.now() - recordingStartTime;
          if (strokeDuration > MAX_STROKE_DURATION_MS) {
            clearLitDots();
            renderGrid();
            velocities = [];
            return;
          }

          // Start the coalesce animation immediately
          startCoalesceAnimation();

          try {
            const response = await fetch(`${API_BASE}/predict`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ velocities: vels }),
            });

            if (!response.ok) {
              const errData = await response.json().catch(() => ({}));
              throw new Error(errData.detail || `HTTP ${response.status}`);
            }

            const data = await response.json();

            // Update output with animation (keep only last MAX_OUTPUT_CHARS)
            decodedOutput += data.predicted_char;
            const displayOutput = decodedOutput.slice(-MAX_OUTPUT_CHARS);
            outputEl.innerHTML = displayOutput.slice(0, -1) +
              `<span class="new-char">${data.predicted_char}</span>`;

            // Remove animation class after it plays
            setTimeout(() => {
              outputEl.textContent = decodedOutput.slice(-MAX_OUTPUT_CHARS);
            }, 300);

            if (typeof data.confidence === "number") {
              confidenceEl.textContent = `${data.confidence.toFixed(1)}%`;
            }
            if (typeof data.inference_ms === "number") {
              inferenceEl.textContent = `${data.inference_ms.toFixed(1)}ms`;
            }
            if (data.image_data_url) {
              previewImg.src = data.image_data_url;
            }
            errorEl.classList.remove("visible");
          } catch (error) {
            console.error("Prediction failed:", error);
            showError(`Error: ${error.message}`);
          }

          velocities = [];
        }

        function getCanvasPos(event) {
          const rect = canvas.getBoundingClientRect();
          const scaleX = canvas.width / rect.width;
          const scaleY = canvas.height / rect.height;

          const clientX = event.touches ? event.touches[0].clientX : event.clientX;
          const clientY = event.touches ? event.touches[0].clientY : event.clientY;

          return {
            x: (clientX - rect.left) * scaleX,
            y: (clientY - rect.top) * scaleY,
          };
        }

        function handleMove(event) {
          event.preventDefault();
          const pos = getCanvasPos(event);

          // If animating, interrupt the animation and start fresh
          if (isAnimating) {
            clearLitDots();
          }

          if (!recordingActive) {
            clearLitDots();
            startRecording(pos);
            lightUpNearbyDots(pos.x, pos.y);
          } else {
            // Interpolate dots along path from last position to current
            lightUpDotsAlongPath(lastCursorPos.x, lastCursorPos.y, pos.x, pos.y);
          }

          currentPos = { x: pos.x, y: pos.y };
          lastCursorPos = { x: pos.x, y: pos.y };
          lastMoveTime = performance.now();

          renderGrid();
        }

        function handleLeave() {
          // Don't do anything special on leave
        }

        // Event listeners
        canvas.addEventListener("mousemove", handleMove);
        canvas.addEventListener("mouseleave", handleLeave);
        canvas.addEventListener("touchmove", handleMove, { passive: false });
        canvas.addEventListener("touchend", handleLeave);

        // Initialize
        initGrid();
        renderGrid();
      })();
    </script>
  </body>
</html>
